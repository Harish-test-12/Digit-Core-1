name: Dynamic Build and Deployment Pipeline

on:
  push:
    branches:
      - master  # Trigger pipeline on changes pushed to the master branch
  # workflow_dispatch:  # Allow manual triggering
    paths:
      - 'core-services/**'  # Trigger only if files within 'core-services' change

jobs:
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      changed-services: ${{ steps.detect.outputs.changed-services }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          fetch-depth: 2  # Fetch the last two commits to allow HEAD~1

      - name: Detect Changed Services
        id: detect
        run: |
          # Get the list of changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD || echo "")
          
          # Filter out unique top-level directories within 'core-services'
          CHANGED_SERVICES=$(echo "$CHANGED_FILES" | grep -E '^core-services/' | cut -d'/' -f2 | uniq)
          
          # Convert to a plain comma-separated string if there are any services
          if [[ -z "$CHANGED_SERVICES" ]]; then
            CHANGED_SERVICES=""
          else
            CHANGED_SERVICES=$(echo "$CHANGED_SERVICES" | tr '\n' ',')
            CHANGED_SERVICES=${CHANGED_SERVICES%,}  # Remove trailing comma
          fi
          
          echo "Changed Services: $CHANGED_SERVICES"
          
          # Output the result as a valid JSON array
          if [[ -n "$CHANGED_SERVICES" ]]; then
            CHANGED_SERVICES_JSON="[\"$(echo $CHANGED_SERVICES | sed 's/,/","/g')\"]"
            echo "::set-output name=changed-services::$CHANGED_SERVICES_JSON"
          else
            echo "::set-output name=changed-services::[]"
          fi
      - name: Debug Output
        run: |
          echo "Changed Services: ${{ steps.detect.outputs.changed-services }}"
  build:
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.changed-services != '[]' }}
    runs-on: ubuntu-latest
    outputs:
      # docker-image: ${{ steps.save-docker-image.outputs.docker-image }}
      db-image2: ${{ steps.save-db-image.outputs.db-image1 || '' }}
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.changed-services) }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Generate the Next Tag
        id: tag
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
        run: |
          echo "Generating the next tag for service: ${{ matrix.service }}"
      
          # Set variables
          BRANCH=${{ github.ref_name }}
          COMMIT_HASH=$(git rev-parse --short HEAD)
          SERVICE_NAME=${{ matrix.service }}
      
          # Log in to Docker Hub and fetch a token
          TOKEN=$(curl -s -X POST "https://hub.docker.com/v2/users/login/" \
            -H "Content-Type: application/json" \
            -d '{"username": "'$DOCKER_USERNAME'", "password": "'$DOCKER_PASSWORD'"}' | jq -r .token)
      
          # Check if the repository exists
          REPO_CHECK=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: JWT $TOKEN" \
            "https://hub.docker.com/v2/repositories/$DOCKER_USERNAME/$SERVICE_NAME/")
      
          if [ "$REPO_CHECK" -ne 200 ]; then
            echo "Repository does not exist. Assuming a first-time build."
            NEXT_TAG="${BRANCH}-${COMMIT_HASH}-1"
          else
            # Fetch existing tags for the service
            EXISTING_TAGS=$(curl -s -H "Authorization: JWT $TOKEN" \
              "https://hub.docker.com/v2/repositories/$DOCKER_USERNAME/$SERVICE_NAME/tags?page_size=100" | jq -r '.results[].name')
      
            # Filter for the current branch and commit hash
            LATEST_TAG=$(echo "$EXISTING_TAGS" | grep "^${BRANCH}-${COMMIT_HASH}-" | sort -V | tail -n 1)
            if [ -z "$LATEST_TAG" ]; then
              # No tag exists for this branch and commit hash
              NEXT_TAG="${BRANCH}-${COMMIT_HASH}-1"
            else
              # Increment the numeric part of the latest tag
              TAG_NUMBER=$(echo "$LATEST_TAG" | awk -F- '{print $NF}')
              NEXT_TAG="${BRANCH}-${COMMIT_HASH}-$((TAG_NUMBER + 1))"
            fi
          fi
      
          # Export the next tag
          echo "::set-output name=tag::$NEXT_TAG"
          echo "NEXT_TAG=$NEXT_TAG" >> $GITHUB_ENV
          echo "Generated Tag: $NEXT_TAG"

      # - name: Build and Push Application Docker Image
      #   id: build_push_docker
      #   uses: docker/build-push-action@v5
      #   with:
      #     context: .
      #     file: build/maven/Dockerfile
      #     push: true
      #     tags: |
      #       ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:${{ steps.tag.outputs.tag }}
      #     build-args: |
      #       WORK_DIR=core-services/${{ matrix.service }}
          
      - name: Check if DB folder exists
        id: check-db-folder
        run: |
          FOLDER_PATH="core-services/${{ matrix.service }}/src/main/resources/db"
          if [ -d "$FOLDER_PATH" ]; then
            echo "folder_exists=true" >> $GITHUB_ENV
          else
            echo "folder_exists=false" >> $GITHUB_ENV
          fi
  
      - name: Build and Push Database Docker Image
        if: ${{ env.folder_exists == 'true' }}
        id: build_push_db_docker
        uses: docker/build-push-action@v5
        with:
          context: core-services/${{ matrix.service }}/src/main/resources/db
          file: core-services/${{ matrix.service }}/src/main/resources/db/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}-db:${{ steps.tag.outputs.tag }}

      # - name: Save Application Docker Image
      #   id: save-docker-image
      #   run: |
      #     DOCKER_IMAGE="${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}:${{ steps.tag.outputs.tag }}"
      #     # echo "$DOCKER_IMAGE" > docker-image.txt
      #     echo "docker-image=$DOCKER_IMAGE" >> $GITHUB_OUTPUT
          
      - name: Save Database Docker Image
        if: ${{ env.folder_exists == 'true' }}
        id: save-db-image
        run: |
          DB_IMAGE="${{ secrets.DOCKER_USERNAME }}/${{ matrix.service }}-db:${{ steps.tag.outputs.tag }}"
          # echo "$DB_IMAGE" > db-image.txt
          echo "db-image1=$DB_IMAGE" >> $GITHUB_OUTPUT

      - name: Show DB Image Output
        run: |
          echo "Database Image: ${{ steps.save-db-image.outputs.db-image1 }}"

      # - name: Set Docker Images in Artifacts
      #   run: |
      #     # Create the artifacts directory if it doesn't exist
      #     mkdir -p ./artifacts
          
      #     # Set the Docker image values
      #     echo "$DOCKER_IMAGE" > ./artifacts/docker-image.txt
      #     echo "$DB_IMAGE" > ./artifacts/db-image.txt
      #   shell: /usr/bin/bash -e {0}
      #   env:
      #     NEXT_TAG: master-e410a69-1
      #     folder_exists: false
  
      # - name: Upload Artifacts
      #   uses: actions/upload-artifact@v3
      #   with:
      #     name: docker-images
      #     path: |
      #       docker-image.txt
      #       db-image.txt
    
      # - name: Show Contents of Text Files
      #   run: |
      #     echo "Contents of docker-image.txt:"
      #     cat docker-image.txt || echo "File docker-image.txt not found!"
          
      #     echo "Contents of db-image.txt:"
      #     cat db-image.txt || echo "File db-image.txt not found!"        
            
      # - name: Debug Outputs
      #   run: |
      #     echo "Docker Image: ${{ steps.save-docker-image.outputs.docker-image }}"
      #     echo "DB Image: ${{ steps.save-db-image.outputs.db-image }}"
        
  Deploy:
    needs: build
    runs-on: ubuntu-latest
    if: ${{ needs.build.outputs.db-image }}"
    steps:
      - name: Debug Docker Image and DB Image
        run: |
          echo "DB_IMAGE1: ${{ needs.build.outputs.db-image2 }}"
